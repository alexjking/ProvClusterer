package uk.co.alexjking.prov.ProvClusterer;

import java.util.ArrayList;
import java.util.List;

import org.openprovenance.prov.model.Document;
import org.openprovenance.prov.model.Element;
import org.openprovenance.prov.model.HasOther;
import org.openprovenance.prov.model.Other;

/**
 * Class which stores information about a clustered document.
 * Extends DocumentData with more functionality for collapsing and expanding documents.
 *
 */
public class ClusteredDocumentData extends DocumentData{

	public ClusteredDocumentData(Document d) {
		super(d);
	}
	
	
	/**
	 * Returns a list of elements with the specified clusterID
	 * @param clusterID
	 * @return
	 */
	public List<Integer> getElementsBelongingToCluster(String clusterID){
		List<Integer> clusterElementIndexes = new ArrayList<Integer>();
		/* Add all elements in the cluster to the list */
		for(int i=0; i<elements.size(); i++){
			Element e = elements.get(i);
			if(isElementInCluster(e, clusterID)){
				clusterElementIndexes.add(i);
			}
		}
		return clusterElementIndexes;
	}
	
	
	
	/**
	 * Checks if specified element is in the specified cluster
	 * @param e
	 * @param clusterID
	 * @return
	 */
	private boolean isElementInCluster(Element e, String clusterID){
		/*
		 * Loop through list of other attributes
		 * returning true if the element has the cluster:id attribute
		 * and the clsuterID parameter matches the value of this attribute
		 */
		if(e instanceof HasOther){
			List<Other> otherAttributes = ((HasOther) e).getOther();
			for(Other attribute: otherAttributes){
				if(attribute.getElementName().getPrefix().equals("cluster") && attribute.getElementName().getLocalPart().equals("id")){
					if(attribute.getValue().equals(clusterID)){
						return true;
					}
				}	
			}
		}
		return false;	
	}
	
	
	
	/**
	 * Calculates the number of times a relation occurs between neighbours of the elements in the given list
	 *  Case 0: Relation hasn't occurred
	 *  Case 1: Relation has occurred once - therefore an external relation
	 *  Case 2: Relation occurs twice - therefore two elements in the list are neighbours thus the relation is internal
	 *  
	 * Used by other functions to find the external and internal relations of a cluster 
	 * 
	 * @param clusterElementIndexes
	 * @return
	 */
	public int[] getRelationOccurrences(List<Integer> clusterElementIndexes){
		int[] relationOccurrences = new int[relations.size()];
		for(int elementIndex: clusterElementIndexes){
			/* Get the list of neighbours */
			List<Integer> neighbourIndexes = neighboursList.get(elementIndex);
			for(int neighbourIndex: neighbourIndexes){
				/* Get relation index */
				int relationIndex = neighbouringElements[elementIndex][neighbourIndex];
				/* Consistency checking */
				if(neighbouringElements[elementIndex][neighbourIndex] != neighbouringElements[neighbourIndex][elementIndex]) 
					System.err.println("You've done something seriously wrong somewhere....");
				/* increment occurrence of the relation */
				relationOccurrences[relationIndex]++;
				if(relationOccurrences[relationIndex] > 2 || relationOccurrences[relationIndex] <0){
					System.out.println("Oh dearry me...");
				}
			}
		}
		return relationOccurrences;
	}

	/**
	 * Gets a list of internal relation indexes
	 * @param relationOccurrences Generated by getRelationOccurrences
	 * @return
	 */
	public List<Integer> getInternalRelationIndexes(int[] relationOccurrences){
		List<Integer> internalRelationIndexes = new ArrayList<Integer>();
		/* Loop through all elements in the cluster */
		for(int i=0;i<relationOccurrences.length; i++){
			if(relationOccurrences[i] == 2){
				internalRelationIndexes.add(i);
			}
		}
		return internalRelationIndexes;
	}
	
	/**
	 * Gets a list of external relation indexes
	 * @param relationOccurrences Generated by getRelationOccurrences
	 * @return
	 */
	public List<Integer> getExternalRelationIndexes(int[] relationOccurrences){
		List<Integer> externalRelationIndexes = new ArrayList<Integer>();
		/* Loop through all elements in the cluster */
		for(int i=0;i<relationOccurrences.length; i++){
			if(relationOccurrences[i] == 1){
				externalRelationIndexes.add(i);
			}
		}
		return externalRelationIndexes;
	}
}
	


